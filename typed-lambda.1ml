module typed_lambda

use "types/std/list"
use "types/std/option"
use "types/equality"

open list;
open option;
open equality;

open struct
  list = List.t;
end;

type Type = sig
  type t a;

  Int : t (type int);
  Arrow a b : t a -> t b -> t (type (a ~> b));
end;

type TQ a = wrap (T : Type) -> T.t a;

TQType : Type = struct
  type t a = TQ a;

  Int = wrap (fun (T : Type) => T.Int) : t (type int);
  Arrow a b (ty1 : t a) (ty2 : t b) =
    let ty1 = unwrap ty1 : t a in
    let ty2 = unwrap ty2 : t b in
      wrap (fun (T : Type) => T.Arrow a b (ty1 T) (ty2 T)) : t (type (a ~> b));
end;

type ExType = wrap sig
  type a;
  tq : TQ a;
end;

ex_type a (tq : TQ a) = wrap struct
  type a = a;
  tq = tq;
end : ExType;

AsInt : Type = struct
  type t a = Option.t (Equality.t a (type int));

  none a = Option.none (Equality.t a (type int));
  some a = Option.some (Equality.t a (type int));

  Int = some (type int) (Equality.refl (type int));

  Arrow a b (ty1 : t a) (ty2 : t b) = none (type (a ~> b));
end;

type ArrowEq a = wrap sig
  type dom;
  type cod;

  eq : Equality.t a (type dom ~> cod);
end;

AsArrow : Type = struct
  type t a = sig
    ty : TQ a;
    eq : Option.t (ArrowEq a);
  end;

  none a = Option.none (ArrowEq a);
  some a = Option.some (ArrowEq a);

  Int = struct
    ty = wrap (fun (T : Type) => T.Int) : TQ (type int);
    eq = none (type int);
  end;

  Arrow a b (ty1 : t a) (ty2 : t b) = struct
    ty = TQType.Arrow a b (ty1.ty) (ty2.ty);

    M = struct
      type dom = a;
      type cod = b;

      eq = Equality.refl (type (a ~> b));
    end;

    eq = some (type (a ~> b)) (wrap M : ArrowEq (type (a ~> b)));
  end;
end;

type Term = sig
  type t;
  type ty;

  Int : int -> t;
  Abs : ty -> t -> t;
  App : t -> t -> t;
end;

TypeCheck = struct
  type Env = list ExType;
  type t = Env ~> ExType;
  type ty = ExType;

  Int (n : int) (env : Env) = ex_type (type int) (TQType.Int);

  Abs (ty1 : ty) (x : t) (env : Env) =
    let ty1 = unwrap ty1 : ty in
    let a = ty1.a in
    let ty2 = unwrap x env : ExType in
    let b = ty2.a in
      ex_type (type (a ~> b)) (TQType.Arrow a b (ty1.tq) (ty2.tq));
end;
